## Design Patterns(Ë®≠Ë®àÊ®°Âºè)

---

* **Ë®≠Ë®àÊ®°ÂºèÁöÑÈ°ûÂûã**
  * Âª∫Á´ãÂûãÊ®°Âºè
    * `Á∞°ÂñÆÂ∑•Âª†Ê®°Âºè(Simple Factory Pattern) `: ‰∏çÂú®23ÂÄãË®≠Ë®àÊ®°ÂºèÂÖß
      * Áî±‰∏ÄÂÄãÂ∑•Âª†‰æÜÁîüÁî¢ÂÖ®ÈÉ®Áî¢ÂìÅ:
        * ÈÅïÂèç¬∑ÂñÆ‰∏ÄËÅ∑Ë≤¨ÂéüÂâá¬∑
        * ÈÅïÂèç¬∑ÈñãÈñâÂéüÂâá¬∑
    * `Â∑•Âª†ÊñπÊ≥ïÊ®°Âºè(Factory Method Pattern)`
      * ÊØèÂÄãÁî¢ÂìÅÈÉΩÂèà1ÂÄãÂÖ∑È´îÂ∑•Âª†Áî¢Áîü
    * `ÊäΩË±°Â∑•Âª†Ê®°Âºè(Abstract Factory Pattern)`
      * Áõ∏ÂêåÁî¢ÂìÅÊóè(Áõ∏ÂêåÁ¥ÑÊùüÁöÑÁî¢ÂìÅ)ÈÉΩÂú®Âêå‰∏ÄÂÄãÂ∑•Âª†ÁîüÁî¢
        * Â∞çÊñºÊñ∞Â¢ûÁî¢ÂìÅÊóèÁ¨¶Âêà`ÈñãÈñâÂéüÂâá`,‰ΩÜÊòØÂ∞çÊñº‰øÆÊîπÊàñËÄÖÂà™Èô§`Áî¢ÂìÅÁ≠âÁ¥öÁµêÊßã`ÈÅïÂèç
    * ÂñÆ‰æãÊ®°Âºè(`Sigleton Pattern`)
      * Âè™Êèê‰æõÈùúÊÖãÊñπÊ≥ïËÆìÂ§ñÈÉ®Â≠òÂèñclass(`getInstance()`),ËÄå‰∏îÁ≥ªÁµ±‰∏≠Âè™Â≠òÂú®‰∏ÄÂÄãInstance
      * `constructor`Â∞çÂ§ñÈö±Ëóè,Â§ñÈÉ®ÁÑ°Ê≥ïÈÄèÈÅénewÁöÑÊñπÊ≥ïÊñ∞Â¢ûInstance
      * ÂÖßÈÉ®Âª∫Á´ãInstance Êúâ2Á®ÆÊñπÊ≥ï
        * È§ìÊº¢Âºè:`static MyClass* myClass = new MyClass() `,Âú®Á≥ªÁµ±ÈÅã‰ΩúÊôÇÂ∞±ÂÖànew Instance
          * ÂïèÈ°å:ÂÅáË®≠Â¶ÇÊûúÊ≤íÊúâ‰ΩøÁî®Âà∞Ë©≤InstanceÊúÉÊµ™Ë≤ªÁ≥ªÁµ±Ë≥áÊ∫ê
        * Êá∂Êº¢Âºè:`static MyClass* myClass = nullptr;`,Âú®`client` call `GetInstance()`ÁöÑÊôÇÂÄôÂú®function Ë£°Èù¢Ê™¢Ê∏¨ `static MyClass* myClass = nullptr` ÊòØÂê¶ÁÇ∫`nullptr` ,`nullptr`Â∞±new InstanceÔºåÂê¶Ââáreturn Instance
          * ÂïèÈ°å:Â§öÁ∑öÁ®ã‰∏≠ÔºåÂèØËÉΩÊòØÊúâÂá∫ÈåØÁöÑÊÉÖÊ≥ÅÔºåÂ§öÂÄãÁ∑öÁ®ãÂêåÊôÇnew,Áî¢Áîü‰∏çÂêåÁöÑInstance
          * Ëß£Ê±∫ÊñπÊ≥ï1:Âä†ÂÖ•`Mutux`‰ª•Âèä‰ΩøÁî®`double-Check Locking`
          * Ëß£Ê±∫ÊñπÊ≥ï2:Âú®classË£°Èù¢Âä†ÂÖ•`static class`,Âè™ÊúâÂú®call ``getInstance()``ÊâçÊúÉÁîüÊàê
        * ÈÅïÂèç`SPP`ÔºåÂèàÊòØÂ∑•Âª†ÂèàÊòØProduct
        * Èõ£Êì¥Â±ïÔºå‰∏çÊòØÊäΩË±°/ÁïåÈù¢
    * ÂéüÂΩ¢Ê®°Âºè(Prototype pattern)-Ëá™Â∑±Â∞±ÊòØ‰∏ÄÂÄãÂ∑•Âª†(Factory)
      * ÈÄöÈÅéË§áË£ΩËá™Â∑±‰æÜÂÖãÈöÜËàáËá™Â∑±‰∏ÄÊë∏‰∏ÄÊ®£ÁöÑClassÔºåËÄå‰∏îË®òÊÜ∂È´î‰∏ç‰∏ÄÊ®£
      * ÂåÖÂê´
        * Ê∑∫ÂÖãÈöÜ(`Shallow-Clone`)(Âè™Êúâvalue type ÊâçÊúÉË¢´Ë§áË£ΩÔºåÂÖ∂‰ªñÂè™ÊúÉË§áË£ΩË®òÊÜ∂È´î‰ΩçÁΩÆ)
        * Ê∑±ÂÖãÈöÜ(`Deep-Clone`)(ÊâÄÊúâÈ°ûÂûãÈÉΩÊúÉË¢´Ë§áË£Ω)
      * ÂèØ‰ª•ÈÄèÈÅé`Prototype manager`‰æÜÈÄ≤Ë°åÂéüÂΩ¢ÂÖãÈöÜÔºåÈÄèÈÅéHashÁöÑÊñπÂºèmatching Ë¶ÅË§áË£ΩÁöÑClass
      * ÈÅïÂèç`OCP`,Â¶ÇÊûúË¶Å‰øÆÊîπ`Clone`ÁöÑÊñπÊ≥ïÔºåÂøÖÈ†à‰øÆÊîπ‰ª£Á¢º
    * ÂâµÂª∫ËÄÖÊ®°Âºè:
      * ÈÄèÈÅé`Builder`ÂÆöÁæ©ÂÖ∑È´îÁöÑÂª∫Á´ãÊñπÊ≥ïËàáÈÖçÁΩÆ,ÈÄöÈÅé`Director`ÈÄ≤Ë°å`Product`ÁöÑÂâµÂª∫ÈÅéÁ®ã(Call `Builder`ÁöÑ`buildPartX ÊñπÊ≥ï`)Ôºå‰∏¶ËøîÂõûÂÆåÊàêÂæåÁöÑ`Product`
      * `Client`Âè™ÊúÉËàá`Director`‰∫íÂãïÔºå‰∏¶‰∏îÁç≤ÂèñÈÖçÁΩÆÂ•ΩÁöÑ`Product`
      * ‰ΩøÁî®`HookMethod`‰Ωø`Director`Êõ¥Â•ΩÁöÑÊéßÂà∂ÂâµÂª∫ÈÅéÁ®ã
      * ÈÅïÂèç:Â¶ÇÊûúÁ∞°Âåñ‰∫Ü`Director`Âêà‰ΩµÂà∞`Builder`ÔºåÂ¶ÇÊûú`Consturct(Âª∫Á´ã)ÊñπÊ≥ï`ÈÅéÊñºË§áÈõúÔºåËÄå‰∏îÈúÄË¶ÅÂêàÊãºËàáÂª∫Á´ãÈÅéÂ§öÁöÑComponents,‰æøÊúÉÈÅïÂèç`SSP`
      * ‰∏çÈÅ©ÂêàÁî¢ÂìÅ/ÂâµÂª∫ÈÅéÁ®ã‰∏çÁõ∏‰ººÁöÑProduct

---

## ÂâµÂª∫ÂûãÊ®°Âºè

> *Êèê‰æõ‰∏ÄÁ®ÆÂª∫Á´ãObjectÁöÑÂêåÊôÇÈö±ËóèlogicÁöÑÊñπÂºè(‰∏çÊòØ‰ΩøÁî®Áõ¥Êé•‰ΩøÁî®new Áõ¥Êé•Âª∫Á´ã)*

+ **`Á∞°ÂñÆÂ∑•Âª†Ê®°Âºè(Simple Factory Pattern)`**-*‰∏çÂú®23ÂÄãË®≠Ë®àÊ®°ÂºèÂÖß*

  > ÂÆöÁæ©:Âª∫Á´ã‰∏ÄÂÄãÊé•Âè£,ËÆìÂ≠êÈ°ûËá™Â∑±Ê±∫ÂÆöÂØ¶ÁèæÂì™‰∏ÄÂÄãFactory
  >
  > ÈáçÈªûÂú®Êñº*Â∑•Âª†*ÔºåÈÄèÈÅéÂ∑•Âª†ÁöÑStatic method ÈÄ≤Ë°åProduct(ÁπºÊâøÊñºÂêå‰∏ÄAbstract)ÁöÑObject
  >
  > **ÈÅïËÉåÂéüÂâá:Open-Close Principe(Êñ∞Â¢ûÁî¢ÂìÅÂøÖÈ†à‰øÆÊîπÂ∑•Âª†)**
  >
  > **Áº∫Èªû:ËÅ∑Ë≤¨Â§™Èáç**
  >
  > ---
  >
  > ```c++
  > //Á∞°ÂñÆüå∞
  > class Product{
  >  public:
  >  	virtual void someMethod() = 0
  > }
  > 
  > class ProductA : public Product{
  >  public:
  >  	void someMethod(){
  >          //TODO For ProductA
  >      }
  > }
  > 
  > class ProductB : Public Product{
  >  public:
  >  	void someMethod(){
  >          //TODO for ProductB
  >      }
  > }
  > 
  > class Factory{
  >  public:
  >  	static Product* getProduct(string type){
  >          if(type == "A"){
  >              return new ProductA();
  >          }
  >          else if(type == "B"){
  >              return new ProductB();
  >          }
  >          return null;
  >      }
  > }
  > 
  > int main(){
  >  Product* A = Factory::getProduct("A"); //get ProductA instance
  >  Product* B = Factory::getProduct("B"); //get ProductB instance
  > 
  > }
  > ```

+ **`Â∑•Âª†Ê®°ÂºèÊ®°Âºè(Factory Pattern)`**

  > ÂÆöÁæ©:Âª∫Á´ã‰∏ÄÂÄãÊé•Âè£,ËÆìÂ≠êÈ°ûËá™Â∑±Ê±∫ÂÆöÂØ¶ÁèæÂì™‰∏ÄÂÄãFactory
  >
  > **ÈáçÈªû**:ÁπºÊâø‰∫ÜSimple Factory PatternsÁöÑÂÑ™Èªû,ÂêåÊôÇËß£Ê±∫‰∫ÜÂÆÉÁöÑÂïèÈ°å(Êñ∞Â¢ûÁî¢ÂìÅÈúÄË¶Å‰øÆÊîπSource)
  >
  > **ÂÑ™Èªû:**
  >
  > * ClientÁÑ°ÈúÄÁü•ÈÅìObjectÁöÑË®≠ÁΩÆÁöÑÁ¥∞ÁØÄÔºå‰πüÁÑ°ÈúÄÁü•ÈÅìÂØ¶Ë≥™ObjectÁöÑÂêçÁ®±ÔºåÂè™ÈúÄÈÄöÈÅéÂ∑•Âª†Âç≥ÂèØ
  > * Â∑•Âª†(Factory)‰ª•ÂèäÁî¢ÂìÅ(Product)ÈÉΩÊòØÈÄèÈÅéPolymorphism(Â§öÊÖã)‰æÜÂØ¶ÁèæÔºå‰πüÊòØÂ∑•Âª†Ê®°ÂºèÁöÑÈóúÈçµÔºåÂ∑•Âª†ÂèØ‰ª•Ëá™‰∏ªÁöÑÊ±∫ÂÆöË¶ÅÁîüÁî¢‰ªÄÈ∫ºÁî¢ÂìÅÔºåÂú®ÂÖßÈÉ®ÈÄ≤Ë°åË®≠ÁΩÆÁî¢ÂìÅ(Â∞ÅË£ùÂú®ÂÖßÈÉ®)
  > * Âä†ÂÖ•Êñ∞ÁöÑProductÊôÇÁÑ°ÈúÄ‰øÆÊîπAbstract class ‰ª•Âèä ÂÖ∑È´îÁöÑÂ∑•Âª†ÂíåÁî¢ÂìÅÁöÑÈ°ûÔºåÂè™Ë¶ÅÊì¥Â±ïÊñ∞Â¢ûÂç≥ÂèØÔºåÁ¨¶ÂêàOpen-Close principle
  >
  > **Áº∫Èªû:**
  >
  > * Êñ∞Â¢ûÁî¢ÂìÅÊôÇÔºåË¶ÅÂä†ÂÖ•Êñ∞ÁöÑÁî¢ÂìÅÈ°û‰ª•ÂèäÂ∑•Âª†È°ûÔºåÂ¢ûÂä†‰∫ÜÁ≥ªÁµ±ÁöÑË§áÈõúÂ∫¶ÔºåËÄå‰∏îÈúÄË¶ÅÂæûÊñ∞Á∑®Ë≠ØÔºåÂ¢ûÂä†‰∫ÜÈñãÈä∑
  > * ÁÇ∫‰∫ÜÊì¥Â±ïÊÄß,Âä†ÂÖ•‰∫ÜÊäΩË±°È°ûÔºåClientÈÉΩ‰ΩøÁî®Abstract class ÈÄ≤Ë°åÁ∑®Á®ãÔºåÂ¢ûÂä†‰∫ÜÁ≥ªÁµ±ÁöÑÊäΩË±°ÊÄßÂíåÁêÜËß£Èõ£Â∫¶(ÈÉΩÊòØAbstract class ‰∏çÁü•ÈÅìÊòØ‰ªÄÈ∫º~)
  >
  > **ÈÄôÂÄãÊ®°ÂºèÂèØ‰ª•ËÆìObject(product)ÁöÑË®≠ÁΩÆÁ∞°ÂåñÔºåclientÁÑ°ÈúÄÁü•ÈÅì/‰∏ÄÁõ¥ÂºÑË§áÈõúÁöÑË®≠ÁΩÆÔºåËÄå‰∏îÈÄèÈÅéÂ§öÊÖãÊÄßÂíå‰ΩøÁî®‰∫ÜÈáåÊ∞èÊõøÊèõÂéüÂâá(Lisko Subsititution princeple)Ôºå‰ΩøÁ≥ªÁµ±Êõ¥ÂÆπÊòìÊì¥Â±ï**
  >
  > ---
  > ```mermaid
  > classDiagram
  > 	FileLoggerFactory ..> FileLogger : create
  > 	DatabaseLoggerFactory  ..> DatabaseLogger : create
  > 
  > 	FileLoggerFactory ..|> LoggerFactory
  > 	DatabaseLoggerFactory ..|> LoggerFactory
  > 
  > 	FileLogger ..|> Logger
  > 	DatabaseLogger ..|> Logger
  > 
  > 	class Logger{
  > 		<<abstruct>>
  > 		+void writeLog()
  > 	}
  > 
  > 	class FileLogger{
  > 		+void writeLog()
  > 	}
  > 
  > 	class DatabaseLogger{
  > 		+void writeLog()
  > 	}
  > 
  > 
  > 	class LoggerFactory{
  > 		<<abstruct>>
  > 		+Logger createLogger()
  > 	}
  > 
  > 	class FileLoggerFactory{
  > 		+Logger createLogger()
  > 	}
  > 
  > 	class DatabaseLoggerFactory{
  > 		+Logger createLogger()
  > 	}
  > 	
  > 
  > 	
  > 	Client ..> LoggerFactory
  > 	Client ..> Logger
  > 
  > ```
  >
  > 
  >
  > ```c++
  > //Factory ÈÄèÈÅéAbstract‰æÜÁπºÊâø/ÂØ¶Áèæ
  > //logger ÁöÑüå∞
  > 
  > //Abstract Logger
  > class Logger{
  >     public:
  >     	virtual void wirteLog() = 0;
  > }
  > 
  > //Implement
  > class DatabaseLogger: public Logger{
  >     pubic:
  >     	void wirteLog(){
  >             //Wirte DB log message
  >         }
  > }
  > 
  > class FileLogger : public Logger{
  >     public:
  >     	void wirteLog(){
  >             //Write File Log message
  >         }
  > }
  > 
  > //Abstruct Factory
  > class Factory{
  >     public:
  >     	virtual Logger* createLogger() = 0;
  > }
  > //‰∏çÂèØ‰ª•ÊòØStaticÈùúÊÖãÔºåÂõ†ÁÇ∫Â≠êÈ°ûÊòØÂãïÊÖãÂØ¶ÁèæÁà∂È°ûÁöÑÂáΩÊï∏(static Ê≤íÊúâthisÊåáÊ®ô)
  > //Implement
  > class FileLoggerFactory : public Factory{
  >     public:
  >     	Logger* createLogger(){
  >             //init file logger 
  >             //TODO init etc
  > 
  >             //create file logger
  >             Logger* logger = new FileLogger();
  >             //TODO Create file etc
  > 
  >             return Logger;
  >         }
  > }
  > 
  > class DabatabaseFactory : public Factory{
  >     public:
  >         Logger* createLogger(){
  >            	//Connect to db
  >             //Create db logger etc...
  >             Logger* logger = new DatabaseLogger();
  >             //init this logger etc...
  >             return logger
  >         }
  > }
  > 
  > //Client to use
  > int main(){
  >     Factory *factory = new FileLoggerFactory();
  >     Logger *logger = factory->createLogger(); //return the Product that it is initialized
  >     Logger->wirteLog();
  >     return;
  > 
  >     //Â¶ÇÊûúÊÉ≥ËÆìÁ≥ªÁµ±ÊúâÊõ¥Â§öÈùàÊ¥ªÊÄßÂíåË™≤Êì¥Â±ïÊÄßÔºåÂèØ‰ª•ÈÄèÈÅéxml‰æÜÈÄ≤Ë°åÈÖçÁΩÆÔºå‰∏çÈúÄÈÄèÈÅé‰øÆÈÅéclientÁöÑ‰ª£Á¢º
  >     //Âè™ÈúÄÊõ¥Êñ∞xml‰∏≠ÁöÑË®≠ÁΩÆÔºåÂú®‰ª£Á¢º‰∏≠Êñ∞Â¢ûÊñ∞ÁöÑProduct ‰ª•ÂèäÊñ∞Â¢ûÁöÑFactory ‰∏¶ÈáçÊñ∞Á∑®Ë≠Ø‰æøÂèØ
  > 
  >     //Èô§‰∫ÜÈªòË™çÁöÑË®≠ÁΩÆÊñπÊ≥ïÂ§ñÔºåÈÇÑÊÉ≥ÈÄèÈÅéÂÇ≥ÂÖ•StringÁöÑÊñπÊ≥ï‰æÜËá™ÂÆöÁæ©Ë®≠Ë®àÔºå‰æãÂ¶ÇÈÄ£Êé•Ë¶ÅDBÔºåÊñá‰ª∂ÁöÑË∑ØÂæëÁ≠âÁ≠â
  >     //ÂèØ‰ª•ÈÄèÈÅéOverride Abstruct class ÁöÑfunc‰æÜÈÄ≤Ë°åË®≠ÁΩÆ
  >     /*
  >     	class Factory{
  >             public:
  >             	virtual Logger* createLogger() = 0;
  >             	virtual Logger* createLogger(string config) = 0;
  >             	virtual Logger* createLogger(Object obj) = 0;//ÈÄöÈÅéObjË£°Èù¢ÁöÑÊàêÂì°ÈÄ≤Ë°åË®≠ÁΩÆÁ≠â
  > 		}
  >     */
  > }
  > 
  > ```

+ **`ÊäΩË±°Â∑•Âª†Ê®°Âºè(Abstract Factory Pattern)`**

  + > ÂÆöÁæ©:
    >
    > Êèê‰æõ‰∏ÄÂÄãÂâµÂª∫Á≥ªÂàóÁõ∏ÈóúÊàñËÄÖ‰∫íÁõ∏‰æùË≥¥ÁöÑInterfaceÔºåËÄåÁÑ°ÈúÄÊåáÂÆöÂÖ∂ÂÖ∑È´îÁöÑclass
    >
    > Abstract Factory PatternÂèàÁ®±ÁÇ∫KitÊ®°Âºè
    >
    > **ÂÑ™Èªû:**
    >
    > * Ëß£Ê±∫Â∑•Âª†Ê®°Âºè‰∏≠ÊØèÂÄãÁî¢ÂìÅÈÉΩ‰ΩøÁî®‰∏ÄÂÄãÂ∑•Âª†ÁöÑÁîüÁî¢ÁöÑÂïèÈ°å
    > * Êñ∞Â¢ûÁî¢ÂìÅÂæàÊñπ‰æøÔºåÊì¥Â±ïÁî¢ÂìÅ‰ª•ÂèäÂ∑•Âª†Âç≥ÂèØ(Â¢ûÂä†Áî¢ÂìÅÊóè)
    > * Â∑•Âª†Ê®°ÂºèÁöÑÂÑ™Èªû
    >
    > **Áº∫Èªû:**
    >
    > * Â¶ÇÊûúË¶ÅÊñ∞Â¢ûÁî¢ÂìÅÁ≠âÁ¥öÁµêÊßãÂøÖÈ†à‰øÆÈÅéÂ∑•Âª†ÊäΩË±°È°ûÔºåÈÅïÂèçOpen-Close ÂéüÂâá(Â¢ûÂä†Áî¢ÂìÅÁ≠âÁ¥öÁµêÊßã)=>*ÈñãÈñâÂéüÂâáÁöÑÂÇæÊñúÊÄß*ÔºàÊäΩË±°Â∑•Âª†Ê®°ÂºèÂîØ‰∏ÄÁº∫ÈªûÔºâ
    >   * **‰ΩïË¨ÇÈñãÈñâÂéüÂâáÁöÑÂÇæÊñúÊÄßÂë¢?**
    >     * Â∞±ÊòØÂú®Êñ∞Â¢ûÁî¢ÂìÅÊóèÁöÑÊôÇÂÄôÂèØ‰ª•Á¨¶ÂêàÈñãÈñâÂéüÂâá,‰ΩÜÊòØÂú®Êñ∞Â¢ûÁî¢ÂìÅÁ≠âÁ¥öÁµêÊßãÊôÇÂÄô(‰∏çÂêåÁöÑÁî¢ÂìÅÈ°ûÂûã/Á≠âÁ¥ö)ÂøÖÈ†à‰øÆÊîπÊäΩË±°È°û(ÁÑ°Ê≥ïËß£Ê±∫ÔºåÂè™ËÉΩÈÅøÂÖç(Ë®≠Ë®àÊôÇ,ÂÖ®Èù¢ËÄÉÊÖÆ!))
    >
    > ---
    >
    > **Â∑•Âª†Ê®°ÂºèË∑üÊäΩË±°Â∑•Âª†ÁöÑÂçÄÂà•**
    >
    > * Â∑•Âª†Ê®°Âºè(Factory Pattern)
    >
    >   * **ÊØè1ÂÄãÁî¢ÂìÅÂ∞çÊáâ1ÂÄãÂÖ∑È´îÂ∑•Âª†Áî®ÊñºÁîüÊàêË©≤Product**
    > * ÊäΩË±°Â∑•Âª†Ê®°Âºè(Factory Pattern)
    >   * ÊØè‰∏ÄÁµÑÁõ∏ÈóúÁöÑProductÈÉΩÁî±Âêå‰∏ÄÂÄãÂÖ∑È´îÂ∑•Âª†ÁîüÁî¢
    >   * ‰æãÂ¶Ç:ÈõªÂô®(ÂêåÁâåÂ≠ê/Âêå‰∏ÄÁî¢ÂìÅÊóè)/ÈõªÂô®(ÂêåÈõªÂô®(Â¶ÇÈÉΩÊòØÂÜ∞ÁÆ±)/Âêå‰∏ÄÁî¢ÂìÅÁ≠âÁ¥öÁµêÊßã)
    >     * **Áî¢ÂìÅÁ≠âÁ¥öÁµêÊßã: Áî¢ÂìÅÁöÑÁπºÊâøÁµêÊßã**
    >       * **Âêå‰∏ÄÁ®ÆÈ°ûÁöÑÁî¢ÂìÅ(Â¶Ç:Âêå‰∏ÄÈõªÂô®‰ΩÜ‰∏çÂêåÁâåÂ≠ê)**
    >     * **Áî¢ÂìÅÊóè:Âêå‰∏ÄÂ∑•Âª†ÁîüÁî¢ÁöÑÔºå‰ΩçÊñº‰∏çÁî®Áî¢ÂìÅÁ≠âÁ¥öÁµêÊßãÁöÑ‰∏ÄÁµÑÁî¢ÂìÅ**
    >       * **Âêå‰∏ÄÊóèÁæ§ÁöÑÁî¢ÂìÅ(Â¶Ç:Âêå‰∏ÄÁâåÂ≠êÁöÑ‰∏çÂêåÈõªÂô®)**
    > ---
    > **‰ΩøÁî®Abstract Factory PatternÁöÑÂØ¶ÈöõÂ†¥Âêà**
    >
    > **Áï∂‰∏ÄÂÄãÂ∑•Âª†ÁöÑÂèØ‰ª•ÂâµÁ´ãÂá∫Â±¨Êñº‰∏çÂêåÁî¢ÂìÅÁöÑÁ≠âÁ¥öÁµêÊßãÁöÑ‰∏ÄÂÄãÁî¢ÂìÅÊóè‰∏≠ÁöÑÊâÄÊúâÂ∞çË±°ÊôÇ,Ê≠§ÊôÇ‰ΩøÁî®ÊäΩË±°Â∑•Âª†Ê®°ÂºèÊõ¥ÊúâÊïàÁéáÂíåÁ∞°ÂñÆ**
    >
    > * **Á≥ªÁµ±‰∏çÊáâË©≤‰æùË≥¥ÂÖ∑È´îÁöÑÁ¥∞ÁØÄ(Â¶Ç‰ΩïÂâµÂª∫,Ë°®ÈÅîÁ¥∞ÁØÄÁ≠â...)Ôºå‰æùË≥¥ËàáÊäΩË±°(ÊâÄÊúâÂ∑•Âª†Ê®°ÂºèÈÉΩ‰∏ÄÊ®£)**
    > * **Á≥ªÁµ±‰∏≠Â§öÊñº‰∏ÄÂÄãÁî¢ÂìÅÊóèÊôÇÔºåËÄåÊØèÊ¨°Âè™ÊúÉ‰ΩøÁî®Âà∞Êüê‰∏ÄÂÄãÁî¢ÂìÅÊóè„ÄÇÂèØÈÄöÈÅéÈÖçÁΩÆÊñá‰ª∂ÂãïÊÖã‰øÆÊîπÁî¢ÂìÅÊóè**
    > * **Á¥ÑÊùü:Â±¨ÊñºÂêå‰∏ÄÁî¢ÂìÅÊóèÁöÑÁî¢ÂìÅÂ∞áÂú®‰∏ÄËµ∑‰ΩøÁî®ÔºåËÄåÈÄô‰∫õÁî¢ÂìÅÂèØ‰ª•Ê≤íÊúâ‰ªª‰ΩïÈóú‰øÇÔºå‰ΩÜÊúâÁõ∏ÂêåÁ¥ÑÊùü**
    > * **Áî¢ÂìÅÁ≠âÁ¥öÁµêÊßãÁ©©ÂÆöÔºåÂú®Ë®≠Ë®àÂÆåÊàêÂæå‰∏çÊúÉÂú®Á≥ªÁµ±Êõ¥Êîπ/Âà™Èô§Áî¢ÂìÅÁ≠âÁ¥öÁµêÊßã(ÈñãÈñâÂéüÂâáÁöÑÂÇæÊñúÊÄß)**
    >
    > ---
    > ``` mermaid
    > classDiagram
    > 	class SkinFactory{
    > 		<<abstruct>>
    > 		+Button createButton()
    > 		+TextFidld createTextField()
    > 		+ComboBox createComboBox()
    > 	}
    > 	
    > 	class SpringSkinFactory{
    > 		+Button createButton()
    > 		+TextFidld createTextField()
    > 		+ComboBox createComboBox()
    > 	}
    > 	
    > 	class SummerSkinFactory{
    > 		+Button createButton()
    > 		+TextFidld createTextField()
    > 		+ComboBox createComboBox()
    > 	}
    > 	
    > 	SpringSkinFactory ..|>  SkinFactory
    > 	SummerSkinFactory ..|>  SkinFactory
    > 	
    > 	class Button{
    > 		<<abstruct>>
    > 		+void display()
    > 	}
    > 	
    > 	class TextField{
    > 		<<abstruct>>
    > 		+void display()
    > 	}
    > 	
    > 	class ComboBox{
    > 		<<abstruct>>
    > 		+void display()
    > 	}
    > 	
    > 	class SpringButton{
    > 		+void display()
    > 	}
    > 	
    > 	class SummerButton{
    > 		+void display()
    > 	}
    > 	
    > 	class SpringTexField{
    > 		+void display()
    > 	}
    > 	
    > 	class SummerTexField{
    > 		+void display()
    > 	}
    > 	
    > 	class SpringComboBox{
    > 		+void display()
    > 	}
    > 	
    > 	class SummerComboBox{
    > 		+void display()
    > 	}
    > 	
    > 	SpringButton ..|> Button
    > 	SummerButton ..|> Button
    > 	
    > 	SpringTexField ..|> TextField
    > 	SummerTexField ..|> TextField
    > 	
    > 	SpringComboBox ..|> ComboBox
    > 	SummerComboBox ..|> ComboBox
    > 	
    > 	SpringSkinFactory  ..> SpringButton : create
    > 	SpringSkinFactory  ..> SpringTexField : create
    > 	SpringSkinFactory  ..> SpringComboBox : create
    > 	
    > 	SummerSkinFactory  ..> SummerButton : create
    > 	SummerSkinFactory  ..> SummerTexField : create
    > 	SummerSkinFactory  ..> SummerComboBox : create
    > 	
    > 	client ..> SkinFactory : use
    > 	client ..> Button : use
    > 	client ..> TextField : use
    > 	client ..> SkinFactory : use
    > 	
    > ```
    >
    > 
    >
    > ```c++
    > //üå∞UI
    > //Button TextField ComboBox
    > //Abstract Class UI
    > class Button{
    >    public:
    >     	virtual void display() = 0;
    > }
    > 
    > class TextField{
    >    public:
    >     	virtual void display() = 0;
    > }
    > 
    > class ComboBox{
    >    public:
    >     	virtual void display() = 0;
    > }
    > 
    > //Abstract Class Factory
    > //Áî®ÊñºÊää‰∏çÂêåÈ°ûÂûãÁöÑUI/‰∏ªÈ°åGroup Âú®‰∏ÄËµ∑
    > class UIFactory {
    >     public:
    >     	virtual Button* createButton() = 0;
    >     	virtual TextField* createTextField() = 0;
    >     	virtual ComboBox* createComboBox() = 0;
    > }
    > ```
    >
    > ```c++
    > //Implenent UI
    > //Spring
    > class SpringButton : public Button{
    >     public:
    >     	void Draw(){
    >             //Draw Spring style Button
    >         }
    > }
    > class SpringTextField : public TextField{
    >     public:
    >     	void Draw(){
    >             //Draw Spring stype TextField
    >         }
    > }
    > class SpringComboBox : public ComboBox{
    >     public:
    >     	void Draw(){
    >             //Draw Spring stype ComboBox
    >         }
    > }
    > 
    > //Summer
    > class SummerButton : public Button{
    >     public:
    >     	void Draw(){
    >             //Draw Summer style Button
    >         }
    > }
    > class SummerTextField : public TextField{
    >     public:
    >     	void Draw(){
    >             //Draw Summer style TextField
    >         }
    > }
    > class SummerComboBox : public ComboBox{
    >     public:
    >     	void Draw(){
    >             //Draw Summer style ComboBox
    >         }
    > }
    > ```
    >
    > ```c++
    > //Implement
    > //Factory
    > class SpringFactory : public UIFactory{
    >     public:
    >     	 Button* createButton(){
    >              //To init the button and some setting
    >              Button* button = new SpringButton();
    >              return button;
    >          };
    >     	 TextField* createTextField(){
    >              //To init the TextField and some setting
    >              TextField* textField = new SpringTextField();
    >              return textField;
    >          };
    >     	 ComboBox* createComboBox(){
    >              //To init the ComboBox and some setting
    >              ComboBox* comboBox = new SpringComboBox();
    > 			return ComboBox;
    >          };
    > }
    > 
    > //SummerFactory
    > class SummerFactory : public UIFactory{
    >     public:
    >        	 Button* createButton(){
    >              //To init the button and some setting
    >              Button* button = new SummerButton();
    >              return button;
    >          };
    >     	 TextField* createTextField(){
    >              //To init the TextField and some setting
    >              TextField* textField = new SummerTextField();
    >              return textField;
    >          };
    >     	 ComboBox* createComboBox(){
    >              //To init the ComboBox and some setting
    >              ComboBox* comboBox = new SummerComboBox();
    > 			return ComboBox;
    >          };
    > }
    > ```
    >
    > ```c++
    > //main
    > int main(){
    >     //Â∞±ÊòØÈÄèÈÅéÂ∑•Âª†ÁîüÊàêÊé•Âè£ÁîüÊàê‰∏çÂêåÁöÑÂ∑•Âª† 
    >     //ÂÜçÈÄèÈÅé‰∏çÂêåÁöÑÂ∑•Âª†Ë™øÁî®ÂÖ∂ÁîüÁî¢ÁöÑproduct
    > 	UIFactory* factory = new SummerFactory();
    >     Button* button = factory->createButton();
    >     TextField* textField = factory->createTextField();
    >     ComboBox* comboBox = factory->createComboBox();
    > 
    >     button->draw();  //Áï´Âá∫Summer StyleÁöÑButton
    >     textField->draw(); //Áï´Âá∫Summer StyleÁöÑtextField
    >     comboBox->draw(); //Áï´Âá∫Summer StyleÁöÑcomboBox
    > 
    >     //ÊúÄÂ•ΩÈÄèÈÅéXMLÊñá‰ª∂Ôºå‰øÆÈÅéXMLÁöÑË®≠ÁΩÆ‰ΩøÁî®‰∏çÁî®StyleÁöÑUI
    >     return;
    > }
    > ```
    >

+ ÂñÆ‰æãÊ®°Âºè(`Singleton Pattern`)

  + > ÂÆöÁæ©(Â∞±ÊòØ‰∏ÄÂÄãÈ°ûÂè™Êúâ1ÂÄãInstance)Ôºö
    >
    > Á¢∫‰øù‰∏ÄÂÄãClassÂè™Êúâ‰∏ÄÂÄãInstance,Êï¥ÂÄãÁ≥ªÁµ±Âè™ÊèêÂÄãÈÄôÂÄãInstance.
    >
    > *Á¢∫‰øùÂîØ‰∏ÄÊÄß,ËÉΩÁØÄÁúÅÁ≥ªÁµ±Ë≥áÊ∫ê*
    >
    > ---
    >
    > **ÂÑ™Èªû:**
    >
    > * Êèê‰æõ‰∫ÜÂîØ‰∏ÄÊÄßÁöÑInstanceË®™Âïè(Á≥ªÁµ±‰∏≠Âè™Êèê‰æõ‰∏ÄÂÄãInstanceË®™Âïè)
    > * SystemÂè™Â≠òÂú®‰∏ÄÂÄãInstance,ÂèØ‰ª•ÁØÄÁúÅÁ≥ªÁµ±Ë≥áÊ∫ê
    > * Âú®ÂñÆ‰æãÊ®°Âºè‰∏≠ÔºåÂèØ‰ª•Êèê‰æõÊåáÂÆöÊï∏ÁõÆÁöÑÂØ¶‰æã(Êï∏ÂÄãInstance)ÔºåËÉΩÁØÄÁúÅÁ≥ªÁµ±Ë≥áÊ∫êÔºåÂêåÊôÇ‰πüËÉΩËß£Ê±∫ÂñÆ‰æãÂ∞çË±°ÂàÜ‰∫´ÈÅéÂ§ö,ÊêçÊÄßËÉΩÁöÑÂïèÈ°å
    >
    > **Áº∫Èªû:**
    >
    > * Êì¥Â±ïÂçÅÂàÜÂõ∞Èõ£(ÂñÆ‰æãÊ®°Âºè‰∏çÊòØÁî±Abstract ClassÂØ¶ÁèæÁöÑ)
    > * ÊúâÈªûÈÅïÂèç‰∫ÜSingle-responsibility PrincipeÔºåÂõ†ÁÇ∫‰ªñÂèàÊòØÂ∑•Âª†ÁöÑËßíËâ≤(new Instance)ÔºåÂèàÊòØProductÁöÑËßíËâ≤(ÂèØ‰ª•ÈÄèÈÅéStaticËøîÂõûÁöÑInstance ÂÅöÊìç‰Ωú)
    >
    > ---
    > ```mermaid
    > classDiagram
    > 	class LoadBalancer{
    > 		-LoadBalancer instance
    > 		-List serverList
    > 		-LoadBalancer()
    > 		+LoadBalancer getiadBalancer()
    > 		+void addServer()
    > 		+void removeServer()
    > 		+string getServer()
    > 	}
    > 	LoadBalancer o-- LoadBalancer : Shared
    > ```
    >
    > 
    >
    > ```c++
    > //Task Manager üå∞
    > //Constructor Â∞çÂ§ñÈö±ËóèÔºå‰∏¶Êèê‰æõ‰∏ÄÂÄãÈùúÊÖãStatic ËÆìÂ§ñÈÉ®Âè™ÈÄèÈÅéÈÄôÂÄãÂ≠òÂèñ
    > class TaskManager{
    > private:
    > 	TaskManager();
    > 	void displayProcess();
    > 	void displayServices();
    > 	static TaskManager* taskManager = nullptr; //‰øùÂ≠òÂîØ‰∏ÄInstance
    > public:
    > 	//Â§ñÈÉ®Âè™ËÉΩÈÄèÈÅéÈùúÊÖãStatic ÊñπÊ≥ïÂ≠òÂèñ ‰∏¶new‰∏ÄÂÄãTaskMangerÁöÑInstance Â¶ÇÊûúÊòØnullÁöÑ
    > 	//Ê≠§ÊñπÊ≥ïÁÇ∫Â∑•Âª†
    > 	static TaskManager* getInstance(){
    > if(taskManager == nullptr){
    >     taskManager = new TaskManager();
    > }
    > return TaskManager;
    > }
    > //‰∏ªË¶ÅStatic ÊñπÊ≥ïÂè™ËÉΩÂ≠òÂèñStatic ËÆäÊï∏ÔºåÂÖ∂‰ªñÂú®ÂØ¶‰æãÂåñÂâçÊòØ‰∏çÂ≠òÂú®ÁöÑ
    > }
    > ```
    >
    > ```c++
    > //LoadBalance üå∞
    > //Áî®ÊñºË®àÁÆóÊúçÂãôÂô®Ë≤†ÂÇµÔºåÊâÄ‰ª•ÂøÖÈ†à‰ΩøÁî®ÂñÆ‰æã
    > LoadBalance::getInstance()
    > class LoadBalance{
    > public:
    > 	static LoadBalance* getInstance(){
    > if(loadBalance == nullptr){
    > 
    >     loadBalance = new LoadBalance();
    > }
    > return LoadBalance;
    > }
    > private:
    > 	static LoadBalance* loadBalance;
    > 	LinkedList* serverList = nullptr;
    > 
    > 	LoadBalance();
    > 	void addServer(std::string server){
    > serverList->add(server);//add a server
    > }
    > 
    > 	std::string getServer(){
    > int i = random()% serverList->length(); //random get server
    > return serverList->get(i);
    > }
    > 
    > }
    > ```
    >
    > ```c++
    > //client
    > int main(){
    > LoadBalance *balancer1,*balancer2,*balancer3,*balancer4;
    > balancer1 = LoadBalance::getInstance(); //Áç≤ÂèñLoadBalanceÔºåÈÄôË£°ÊúÉÂÖànew ÂÜçreturn
    > balancer2 = LoadBalance::getInstance(); //Áç≤ÂèñLoadBalance
    > balancer3 = LoadBalance::getInstance(); //Áç≤ÂèñLoadBalance
    > balancer4 = LoadBalance::getInstance(); //Áç≤ÂèñLoadBalance
    > 
    > //‰ª•‰∏ä4ÂÄãbalancer ÈÉΩÊáâË©≤ÁÇ∫Âêå‰∏ÄË®òÊÜ∂È´î
    > if(balancer1 == balancer2 && balancer2 == balancer3 && balancer3 == balancer4)
    > printf("Balancer is Unquie0");
    > 
    > //add server
    > balancer1->addServer("server1");
    > balancer1->addServer("server2");
    > balancer1->addServer("server3");
    > balancer1->addServer("server4");
    > 
    > for(int i = 0;i<10;i++){
    > printf("server %d",balancer1->getServer());
    > }
    > return;
    > }
    > ```
    >
    > ---
    >
    > **Singleton PatternÁöÑÂïèÈ°å(Â¶Ç‰Ωïinitialize InstanceÂë¢Ôºü)**
    >
    > * **Multi-Threading ÂêåÊôÇCall getInstance()**
    >   * Â¶ÇÊûúThread A Ë∑ü Thread BÂêåÊôÇInstance ÁÇ∫null ÁöÑÊôÇÂÄô call getInstance()ÔºåÊúÉÂêåÊôÇÈÄ≤ÂÖ•if-conditionÔºå‰∏¶ÈÉΩÊúÉÈÄ≤Ë°ånewÔºå‰πüÂ∞±ÈÅïÂèç‰∫ÜSingleton PatternÁöÑÁõÆÁöÑÔºåÂèØËÉΩÂ∞éËá¥Á≥ªÁµ±ÈåØË™§„ÄÇ
    >
    > * **2Á®ÆËß£Ê±∫ÊñπÊ≥ï**
    >   * *È§ìÊº¢ÂºèSingleton*
    >
    >     * Â∞±ÊòØÂú®ÂÆöÁæ©Static variableÁöÑÊôÇÂÄôÂ∞±new InstanceÔºåÊâÄ‰ª•Âú®class Âä†ËºâÊôÇÂÄôÂ∞±Â∑≤Á∂ìË¢´ÂØ¶‰æãÂåñ‰∫Ü
    >     * ÂïèÈ°å:ÁÑ°Ë´ñÁ≥ªÁµ±ÊòØÂê¶‰ΩøÁî®ÈÄôÂÄã,ÂÆÉÈÉΩÊúÉÂØ¶‰æãÂåñ
    >
    >   * *Êá∂Êº¢ÂºèSingleton(Lazy load)*
    >
    >     * Â∞±ÊòØÂú®call ``getInstance()``ÊôÇÂÄôÔºåÂÖàÊ™¢Ê∏¨ÊòØÂê¶Â≠òÂú®Ôºå‰∏çÂ≠òÂú®(nullptr)ÁöÑÊôÇÂÄôÔºåÂÖànew InstanceÂÜçreturn Instance
    >
    >       ```c++
    >       static MyClass* getInstance(){
    >           if(myClass == nullptr) myClass = new MyClass();
    >           return myClass;
    >       }
    >       ```
    >
    >     * ÂïèÈ°å1:Âú®Â§öÁ∑öÁ®ã(Multi-threading)ÁöÑÊôÇÂÄôÔºåÊúÉÊúâÁ∑öÁ®ãÂÆâÂÖ®(ÈúÄË¶ÅÁî®Âà∞mutex‰øùË≠∑)
    >
    >       ```c++
    >       //suppse mutex is a keywork in c++ for 
    >       mutux static MyClass* getInstance(){
    >           if(myClass == nullptr) myClass = new MyClass();
    >           return myClass;
    >       }
    >       //ÈÄôÂÄãÂïèÈ°åÂ∞±ÊòØÊØèÊ¨°call getInstance ÈÉΩÊúÉÈéñÔºåÂΩ±ÈüøÊÄßËÉΩ
    >       ```
    >
    >       ```c++
    >       //suppse mutex is a keywork in c++ for 
    >       static MyClass* getInstance(){
    >           if(myClass == nullptr){
    >               mutex funcPtr(){
    >                   myClass = new MyClass();
    >               }
    >           }
    >           return myClass;
    >       }
    >       //ÈÄôÂÄãËß£Ê±∫‰∫Ü‰∏äÈù¢ÁöÑÂïèÈ°å
    >       //‰ΩÜÊòØ ÈÇÑÊòØÊúÉÂá∫ÂïèÈ°å
    >       //Âõ†ÁÇ∫Á∑öÁ®ãÈÇÑÊòØÊúÉÂêåÊôÇÈÄ≤Âéªif condition
    >       //ÊâÄ‰ª•Ë¶ÅÂú®‰∏ÄÂÄãif ÂÜçÈÄ≤Ë°åÂà§Êñ∑
    >       //Á®±ÁÇ∫double-Check Locking
    >       ```
    >
    >       ```c++
    >       //double-Check Locking
    >       mutux static MyClass* getInstance(){
    >           if(myClass == nullptr){
    >               mutex funcPtr(){
    >                   if(myClass == nullptr){
    >                        myClass = new MyClass();
    >                   }
    >               }
    >           }
    >           return myClass;
    >       }
    >       //Ê™¢Êü•2Ê¨°
    >       ```
    >
    >  * ‰ΩøÁî®ÂÖßÈÉ®Static class ‰æÜÈÄ≤Ë°åÂØ¶Áèæ
    >
    >     * ËÉΩÂÖãÊúç``È§ìÊº¢Âºè``Ë∑ü``Êá∂Êº¢Âºè``
    >
    >       ```c++
    >       class Singleton {
    >           private:
    >       		 Singleton() {
    >       			}
    >       	static class HolderClass {
    >                   private:
    >               		static Singleton* instance = new Singleton();
    >       	}
    >       	public:
    >           	static Singleton getInstance() {
    >       	    	return HolderClass::instance
    >       		}
    >       	}
    >                               
    >       //Â∞±ÊòØÈùúÊÖãÂñÆ‰æãÊ≤íÊúâ‰ΩúÁÇ∫SingletonÁöÑÊàêÂì° ÊâÄ‰ª•Âä†ËºâÊôÇÂÄô‰∏çÊúÉË¢´ÂØ¶‰æãÂåñ
    >       //getInstance()Ë¢´ÂëºÂè´ÊôÇÂÄôÊâçÊúÉÂëºÂè´HolderClass ‰∏¶ÂØ¶‰æãÂåñ
    >       ```
    >

+ ÂéüÂûãÊ®°Âºè(Prototype Pattern)

  + > ÂÆöÁæ©:
    >
    > ‰ΩøÁî®Prototype InstanceÊåáÂÆöÂª∫Á´ãÁöÑObjectÁöÑÈ°ûÂûãÔºåÈÄöÈÅéË§áË£ΩËá™Â∑±ÂâµÂª∫Êñ∞ÁöÑInstance
    >
    > (Âª∫Á´ãÊàñËÄÖË§áË£Ω‰∏ÄÂÄãË∑üËá™Â∑±‰∏ÄÊ®£ÁöÑInstanceÔºåÈáçÈªûÂú®ÊñºÂ¶ÇÊûúÂØ¶Áèæ``Clone``ÊñπÊ≥ï)
    >
    > ----
    >
    > **ÂÑ™Èªû:**
    >
    > * ÂèØ‰ª•Á∞°ÂåñÂª∫Á´ãÂ∞çË±°ÁöÑÈÅéÁ®ãÔºåÁõ¥Êé•Ë§áË£ΩÂ∑≤ÊúâÁöÑInstance(Ê®°Êùø)ÔºåÊèêÂÄãÂâµÂª∫ÁöÑÊïàÁéá
    > * Êì¥Â±ïÊÄßÂ•ΩÔºåPrototype Êèê‰æõ‰∫ÜÊäΩË±°È°ûÔºåClientÂèØÂ∞çÊäΩË±°È°ûÁ∑®Á®ãÔºåÂ∞çÁ≥ªÁµ±ÈÅã‰ΩúÊ≤íÊúâ‰ªª‰ΩïÂΩ±Èüø(Êñ∞Â¢ûÊàñÊ∏õÂ∞ë)
    > * ÁÑ°ÈúÄÂ∑•Âª†(Ëá™Â∑±Â∞±ÊòØÂ∑•Âª†)ÔºåÈÄèÈÅéclone ÊñπÊ≥ïÈÄ≤Ë°åÂª∫Á´ãÁöÑÈÅéÁ®ã(Ë§áË£ΩËá™Â∑±‰æÜÂâµÂª∫)
    > * ÂèØ‰ª•‰ΩøÁî®`Deep Copy`ÂÇô‰ªΩPrototypeÁöÑstate
    >
    > **Áº∫Èªû:**
    >
    > * ÊØèÂÄãPrototype class ÈÉΩÂøÖÈ†àÂÖ∑ÊúâClone ÊñπÊ≥ïÔºåËÄå‰∏îË¶Å‰øÆÊîπClone ÂøÖÈ†à‰øÆÊîπsourceÔºåÈÅïËÉå`SPP`
    > * `Deep Copy`ÂØ¶ÁèæËµ∑‰æÜÊØîËºÉË§áÈõúÔºåÂ¶ÇÊûúObjectÊúâÂ§öÂÄãObject ÂµåÂ•ó(embedded),ÈÉΩÈúÄË¶ÅÂ∞çÊØèÂÄãClassÈÄ≤Ë°å`Deep Copy`ÔºåÂèØËÉΩÂØ¶ÁèæÈ∫ªÁÖ©
    >
    > ---
    >
    > **ÈÅïËÉåÂéüÂâá:**
    >
    > * Â¶ÇÊûú‰øÆÊîπPrototype ÁöÑClone ÊñπÊ≥ïÊúÉÈÅïËÉå``OCP``
    >
    > ---
    > ```mermaid
    > classDiagram
    > 	class Object{
    > 		<<abstruct>>
    > 		+Object Clone()
    > 	}
    > 
    > 	class Log{
    > 		-string name
    > 		-string data
    > 		-string content
    > 		+void setName(string name)
    > 		+void setData(string date)
    > 		+void setContent(string content)
    > 		+string getName()
    > 		+string getData()
    > 		+strint getContnent()
    > 		+Object Clone()
    > 	}
    > 
    > 	Log --|> Object
    > 	Client ..> Log
    > ```
    >
    > 
    >
    > ```c++
    > //Á∞°ÂñÆÁöÑPrototypeÁöÑüå∞
    > //Prototype ÂèØ‰ª•ÊòØÊäΩË±°(Abstruct)/Interface(Êé•Âè£)/ÁîöËá≥ÂèØ‰ª•ÊòØÂØ¶‰æã(Instance)
    > class Prototype{
    >     public:
    >     	virtual Prototype* clone() = 0
    > }
    > 
    > class PrototypeA : public Prototype{
    >     private:
    >     	int attr;
    >     public:
    >     	int getNum(){
    >             return this->attr;
    >         }
    >     	void setAttr(int num){
    >             //TODO set attr
    >             this->attr = num;
    >         }
    >     	 Prototype* clone(){
    >           	//To clone self Object with new
    >              Prototype* cloneObj = new PrototypeA();
    >              cloneObj->setAttr(this->attr);
    >              return cloneObj;
    >          }
    > 
    > }
    > 
    > class PrototypeB : public Prototype{
    >     private:
    >     	int attr;
    > 
    >     public:
    >         int getNum(){
    >             return this->attr;
    >         }
    >     	void setAttr(int num){
    >             //TODO set attr
    >             this->attr = num;
    >         }
    >     	 Prototype* clone(){
    >           	//To clone current Object with new
    >              Prototype* cloneObj = new PrototypeB();
    >              cloneObj->setAttr(this->attr);
    >              return cloneObj
    >          }
    > }
    > 
    > int main(){
    >     //ÂÖànew ‰∏ÄÂÄãInstance ÔºåÂÜçÈÄèÈÅécall clone method ÈÄ≤Ë°åClone
    > 
    >     //Clone A and store in CloneObjA
    >     //Ë§áË£ΩAÁöÑPrototype(Ê®°Êùø)
    >     Prototype* objA = new PrototypeA();
    >     Prototype* CloneObjA = onjA->Clone();
    > 
    > 
    >     //Clone B and store in CloneObjB
    >     //Ë§áË£ΩBÁöÑPrototype(Ê®°Êùø)
    >     Prototype* objB = new PrototypeB();
    >     Prototype* CloneObjB = onjB->Clone();
    >     return;
    > }
    > ```
    >
    > > **Ê≥®ÊÑè:Clone ‰∏çÊáâË©≤ÊòØÁõ∏ÂêåÁöÑË®òÊÜ∂È´î‰ΩçÁΩÆÔºå``return this/return self``**
    >
    > ---
    >
    > **Ë§áË£ΩPrototype ÁöÑÂïèÈ°å**
    >
    > * **2ÂÄãË§áË£ΩÁöÑconcept**
    >
    > * *Ê∑∫ÂÖãÈöÜ(Shallow Clone)*:Âè™Êúâ``value``È°ûÂûãÊúÉË¢´Ë§áË£Ω
    >
    >   * >cloneÁöÑPrototypeÁöÑvalue``ÁöÑÈ°ûÂûãÔºå``value``È°ûÂûãÊúÉË§áË£Ω‰∏Ä‰ªΩÁµ¶Clone Object
    >     >
    >     >cloneÁöÑPrototypeÁöÑ``reference``È°ûÂûãÔºå``reference``È°ûÂûãÊúÉË§áË£ΩËá™Â∑±ÁöÑË®òÊÜ∂È´î‰ΩçÁΩÆÁµ¶Clone Object,‰πüÂ∞±ÊòØ2ÂÄãObjectÁöÑ``reference``È°ûÂûãÈÉΩÊúÉpointer to Âêå‰∏ÄÂÄãË®òÊÜ∂È´î‰ΩçÁΩÆ.ÔºàÂÄºÊ≤íÊúâË¢´Ë§áË£ΩÔºâ
    >
    > * Ê∑±ÂÖãÈöÜ(Deep Clone):ÊâÄ‰ª•ÊàêÂì°ÈÉΩÊúÉË¢´Ë§áË£Ω
    >
    >   * >cloneÁöÑPrototypeÁöÑ``value``ÁöÑÈ°ûÂûãÔºå``value`` È°ûÂûãÊúÉË§áË£Ω‰∏Ä‰ªΩÁµ¶Clone Object
    >     >
    >     >cloneÁöÑPrototypeÁöÑ``reference``È°ûÂûãÔºå‰πüÊúÉË§áË£Ω‰∏Ä‰ªΩclone object.(Ë®òÊÜ∂È´îÊòØ‰∏ç‰∏ÄÊ®£)
    >     >
    >     >ÊâÄ‰ª•ÊàêÂì°ÈÉΩÊúÉË¢´Ë§áË£Ω
    >
    > ```c++
    > //ShallowClone and DeepClone in c++
    > //Â¶ÇÊûúË¶ÅË§áË£Ωpointer Â∞±Âæó‰ΩøÁî®DeepClone
    > //Âú®c++‰∏≠default‰ΩøÁî®ShallowClone
    > ```
    >
    > ---
    >
    > **ÈÄèÈÅéPrototype Manager(ÂéüÂΩ¢ÁÆ°ÁêÜÂô®)‰æÜË§áË£Ω‰∏çÂêåÁöÑPrototype**
    >
    > > Prototype Manager = Ë≤†Ë≤¨Âª∫Á´ãPrototypeÁöÑFactory
    > >
    > > ÈÄèÈÅéPMË£°Èù¢ÁöÑHash‰æÜÁç≤ÂèñË¶ÅË§áË£ΩÁöÑPrototype
    > ```mermaid
    > classDiagram
    > 	class Prototype{
    > 		<<absstruct>>
    > 		+Prototype clone()
    > 	}
    > 	
    > 	class ConcretePrototypeA{
    > 		+Prototype Clone()
    > 	}
    > 	
    > 	class ConcretePrototypeB{
    > 		+Prototype Clone()
    > 	}
    > 	
    > 	ConcretePrototypeA --|> Prototype
    > 	ConcretePrototypeB --|> Prototype
    > 	
    > 	class PrototypeManager{
    > 		-Map PrototypeMap
    > 		+void add(string,Prototype)
    > 		+Prototype get(string)
    > 	}
    > 	
    > 	client ..> PrototypeManager : create
    > 		client ..> Prototype
    > ```
    >
    > ```mermaid
    > classDiagram
    > 	class Document{
    > 		<<abstruct>>
    > 		+Document clone()
    > 		+void display()
    > 	}
    > 	
    > 	class FAR {
    > 		+Document clone()
    > 		+void display()
    > 	}
    > 	
    > 	class SRS{
    > 		+Document clone()
    > 		+void display()
    > 	}
    > 	
    > 	class DRS{
    > 		+Document clone()
    > 		+void display()
    > 	}
    > 	
    > 	FAR ..|> Document
    > 	SRS ..|> Document
    > 	DRS ..|> Document
    > 	
    > 	class PrototypeManager{
    > 		-prototypeMap Map 
    > 		-PrototypeManager static 
    > 		+PrototypeManager()
    > 		+AddDoc(string,Document) void 
    > 		+getDoc() Document 
    > 		+getPrototypeManager() static PrototypeManager
    > 	}
    > 	
    > 	client ..> PrototypeManager
    > 	client ..> Document
    > ```
    >
    > 
    >
    > ```c++
    > //ÁîüÊàê‰∏çÂêåÊñá‰ª∂Ê®°ÊùøÁöÑÊ†óÂ≠ê
    > class OfficialDocument{
    >     public:
    >     	virtual OfficialDocument* clone() = 0;
    >         virtual void display() = 0;
    > }
    > 
    > //Feasibility Analysis Report
    > class FAR : OfficialDocument{
    >     public:
    >     	OfficialDocument* clone(){
    >             //ShallowCopy Ê∑∫Ë§áË£Ω
    >             //ÁúÅÁï•‰ª£Á¢º...
    >         }
    >     	void display(){
    >             printf("FAR document");
    >         }
    > }
    > 
    > //Software Requirements Specification
    > class SRS  : OfficialDocument{
    >     public:
    >     	OfficialDocument* clone(){
    >             //ShallowCopy Ê∑∫Ë§áË£Ω
    >             //ÁúÅÁï•‰ª£Á¢º...
    >         }
    >     	void display(){
    >             printf("FAR document");
    >         }
    > }
    > 
    > //Factory-using Singleton pattern ‰ΩøÁî®È§ìÊº¢Âºè
    > class PrototypeManager{
    >     private:
    >     	map<std::string,OfficialDocument*> hashMap;
    >     	static PrototypeManager* pm = new PrototypeManager();
    >     	PrototypeManager(){
    >             hashMap["far"] = new OfficialDocument();
    >             hashMap["srs"] = new OfficialDocument();
    >         }
    > 
    >     public:
    >     	void addOfficeDoc(std::string,OfficialDocument* doc){
    >             //add pair to hashMap and instance
    >         }
    > 
    >         OfficialDocument* getOfficeDoc(std::string key){
    >             //get OfficialDocument clone from map for the key
    >             //return the clone
    >         }
    > 
    >     	static PrototypeManager* getInstance(){
    >             return pm;
    >         }
    > }
    > 
    > int main(){
    >     PrototypeManager* pm = PrototypeManager::getInstance();
    >     //get Feasibility Analysis Report clone
    >     OfficialDocument doc1 = pm->getOfficeDoc("far");
    >     OfficialDocument doc2 = pm->getOfficeDoc("far");
    > 
    >     OfficialDocument doc3 = pm->getOfficeDoc("src");
    >     OfficialDocument doc4 = pm->getOfficeDoc("src");
    > 
    >     //ÈÄèÈÅékey value patterns Áç≤ÂèñË¶ÅcloneÁöÑInstance
    > 
    >     return;
    > }
    > ```


* ÂâµÈÄ†ËÄÖÊ®°Âºè(Builder pattern)


  * > ÂÆöÁæ©(Â§öÂÄã‰∏çÂêåÁöÑcomponents ÁµÑÊàêË§áÈõúÁöÑProduct):
    >
    > Â∞á‰∏ÄÂÄãË§áË£ΩÁöÑObjectÁöÑÂª∫ÊßãËàáÂÆÉÁöÑË°®Á§∫(ÁµÑ‰ª∂Component)ÂàÜÈõ¢Ôºå‰ΩøÂæóÂêåÊ®£ÁöÑÂª∫ÊßãÈÅéÁ®ã(ComponentÁöÑÂª∫Êßã)ÂèØ‰ª•ÂâµÂª∫‰∏çÂêåÁöÑË°®Á§∫(Âêå‰∏ÄÂÄãComponentÂèØ‰ª•Ëàá‰∏çÁî®ÁöÑComponentsÁµÑÂêà)
    >
    > > **ËàáÊäΩË±°Â∑•Âª†(Absturct)ÁöÑÂçÄÂà•**
    > >
    > > * ÊäΩË±°Â∑•Âª†:Â∞±ÊòØÁîüÁî¢Êüê‰∏ÄÂÄãÈÉ®‰ª∂ÁöÑÂ∑•Âª†ÔºåËÄå‰∏îÊòØÊîæÂõû‰∏Ä‰∫õ‰∫ÜÁõ∏ÈóúÁöÑProduct
    > > * ÂâµÂª∫ËÄÖÊ®°Âºè:ÈÄöÈÅéÂÖ∑È´îÁöÑBuilderÂéªÊåáÂ∞éDirectorÂéªÁîüÊàêË§áÈõúÁöÑÂ∞çË±°
    >
    > ---
    >
    > **ÂÑ™Èªû**
    >
    > * ClientÁÑ°ÈúÄÁü•ÈÅìÂª∫Á´ã/ÁµÑÊàêÁî¢ÂìÅÁöÑÁ¥∞ÁØÄÔºåËÆìClientÂú®Áõ∏ÂêåÁöÑÈÅéÁ®ã‰∏ã(Builder‰∏ç‰∏ÄÊ®£)Â∞±ÂèØ‰ª•Âª∫Á´ãÂá∫‰∏çÁî®ÁöÑProduct
    > * ÊØè‰∏ÄÂÄãÂÖ∑È´îÁöÑ`Builder`ÈÉΩÊòØ‰∫íÁõ∏Áç®Á´ãÁöÑÔºåÂ¶ÇË¶ÅÊñ∞Â¢û`Builder`ÁöÑÂÖ∑È´îclassÔºåÁõ¥ÈÄ≤Ë°åÊì¥Â±ï„ÄÇËÄå‰∏î`Director`ÊòØÂ∞ç`Absbstruct class`ÈÄ≤Ë°åÁ∑®Á®ã,ÊâÄ‰ª•ÁÑ°ÈúÄ‰øÆÊîπ‰ª£Á¢ºÔºåÁ¨¶Âêà`Open-Close Principe`,‰∏îÁ≥ªÁµ±Êì¥Â±ï‰πüÊñπ‰æø
    > * ÂèØ‰ª•Â¢ûÂä†Á®ãÂ∫è(`HookMethod`)‰æÜÊõ¥Á≤æÁ¥∞ÂæóÊéßÂà∂ÂâµÂª∫ÈÅéÁ®ã
    >
    > **Áº∫Èªû**
    >
    > * ÊØèÂÄãÁî¢ÂìÅÁöÑÂª∫Á´ãÈÉΩÊúâÁõ∏‰ººÁöÑÈÉ®ÂàÜÔºåÂú®ÈÄôÁ®ÆÊÉÖÊ≥Å‰∏ãÊâçÈÅ©ÂêàÁî®`Builder Patterns`,Â¶ÇÈÇ£Á®ÆÂæàÂ§öComponentÈÉΩ‰∏ç‰∏ÄÊ®£ÁöÑÔºå‰∏çÈÅ©Âêà‰ΩøÁî®ÔºåÊâÄ‰ª•Ôºå‰ΩøÁî®ÂèóÂà∞ÈôêÂà∂
    > * Â¶ÇÊûúÊüêÂÄãProductÈúÄË¶ÅÂ§öÂÄãBuilder‰æÜÂØ¶ÁèæË§áÈõúÁöÑËÆäÂåñÔºåÊúÉÂ∞éËá¥Âê∏ÂºïËÆäÂæóÈæêÂ§ßÔºåÊúÉÂ¢ûÂä†Á≥ªÁµ±ÁöÑÁêÜËß£Èõ£ÈªûÂíåÈÅãË°åÊàêÊú¨
    >
    > ---
    >
    > *Ê¶ÇÂøµ*:
    >
    > > Builder:ÁÇ∫ÊäΩË±°(Abstuct)/ÁïåÈù¢(Interface),Êèê‰æõÂâµÂª∫ÂêÑÈÉ®ÂàÜÁöÑMethod ‰ª•ÂèäreturnÁöÑProduct
    > >
    > > ConcreteBuilder:Implement Builder ÔºåÊèê‰æõÂêÑÂÄãComponentÁöÑÂª∫Á´ãÊñπÊ≥ï‰ª•ÂèäË£ùÂÇôÊñπÊ≥ï
    > >
    > > Product :ÂåÖÂê´Â§öÂÄãComponentsÁöÑË§áÈõúObject
    > >
    > > Director : Ë≤†Ë≤¨ÂÆâÊéíBuilderÁµÑË£ùÁöÑÈ†ÜÂ∫èÔºåClientÊúÉ‰πãÈñìËàáDirector ÈÄ≤Ë°å‰∫íÂãïÔºåÈÉΩÈÅésetterÁ≠âÊ≥®ÂÖ•ÊñπÂºèÈÖçÁΩÆË§áÈõúObjectÁöÑÂ±¨ÊÄß
    >
    > ---
    > ```c++
    > //Á∞°ÂñÆÁöÑ‰æãÂ≠ê
    > //Product class
    > class Product{
    >     private:
    >     	//ÁµÑÊàêÁöÑComponent
    >     	std::string partA;
    >     	std::string partB;
    >     	std::string partC;
    >     public:
    >     //ÂêÑÂÄãComponentÁöÑË®≠ÁΩÆ‰ª•ÂèäÁç≤ÂèñÊñπÊ≥ï
    >     //PartA,B,CÁöÑsetterË∑ügetter
    > }
    > ```
    >
    > ```c++
    > //Builder ÁöÑAbstract ÔºöbuilderÂ∞áÊúÉÂØ¶Áèæ‰ªÄÈ∫ºÊñπÊ≥ï
    > class Builder{
    >     protected Product* product = new Product(); //Êñ∞Âª∫Product,ÈÄèÈÅésetter getter ÂéªÊîπËÆä
    >     pubilc:
    >     	virtual void buildPartA() = 0;
    >     	virtual void buildPartB() = 0;
    >     	virtual void buildPartC() = 0;
    > 
    >     	//Â∑•Âª†ÊñπÊ≥ï
    >     	Product *getResult(){
    >             return product
    >         }
    > }
    > ```
    >
    > ```c++
    > //Director :Âª∫Á´ãProductÁöÑÈ†ÜÂ∫èÔºå‰ª•ÂèäÂàÜÈõ¢ClientÂíåCreation
    > class Director{
    >     private:
    >     	Builder* builder; //Áî®‰ªÄÈ∫ºbuilder Âéªbuild Product
    >     public:
    >     	Director(Builder* builder){
    >             this->builder = builder
    >         }
    > 
    >     	//‰øÆÊîπProductÁöÑÂª∫Á´ãÁöÑbuilder
    >     	void setBuilder(Builder* builder){
    >             this->builder = builder
    >         }
    > 
    >     	Product* productBuild(){
    >             //Â¶Ç‰ΩïÂª∫Á´ãProduct
    >             //ÂÅáË®≠È†ÜÂ∫èA B C
    >             builder->buildPartA();
    >             builder->buildPartB();
    >             builder->buildPartC();
    >             return builder->getResult(); //ÂÆåÊàêÂæåËøîÂõû
    >         }
    > }
    > 
    > ```
    >
    > ```c++
    > //Client
    > int main(){
    >     Builder* builder = new ConcreteBuilder(); //‰ΩøÁî®Ê≠§builder Âª∫Á´ãProduct
    >     Director* director = new Director(builder);
    >     Product* product = director->construct(); //ËøîÂõû Âª∫Á´ãÂ•ΩÁöÑProduct
    >     //...
    >     return
    > }
    > ```
    >
    > ---
    >
    > ```mermaid
    > classDiagram
    > 	ActorBuilder <|-- HeroBuilder
    > 	ActorBuilder <|-- AngelBuilder
    > 	ActorBuilder <|-- DevilBuilder
    > 	ActorBuilder *-- Actor
    > 	ActorController ..> ActorBuilder
    > 
    > 
    > 	class Actor{
    >         -type : stirng
    >         -sex : string
    >         -face : string
    >         -constume : string
    >         -hairstyle : string
    >         +void setType(string type)
    >         +void setSex(string type)
    >         +void setFace(string type) 
    >         +void setCostume(string type)
    >         +void setHairStyle(string type) 
    >         +string getType()
    >         +string getSex()
    >         +string getFace()
    >         +string getCostume()
    >         +string getHairStyle()
    > 	}
    > 
    > 	class ActorBuilder{
    > 		#actor:Actor
    > 		+void buildType()
    > 		+void buildSex()
    > 		+void buildFace()
    > 		+void buildCostume()
    > 		+void buildHairStyle()
    > 		+Actor createActor()
    > 	}
    > 
    > 	class HeroBuilder{
    > 		#actor:Actor
    > 		+void buildType()
    > 		+void buildSex()
    > 		+void buildFace()
    > 		+void buildCostume()
    > 		+void buildHairStyle()
    > 		+Actor createActor()
    > 	}
    > 
    > 	class AngelBuilder{
    > 		+void buildType()
    > 		+void buildSex()
    > 		+void buildFace()
    > 		+void buildCostume()
    > 		+void buildHairStyle()
    > 	}
    > 
    > 	class DevilBuilder{
    > 		+void buildType()
    > 		+void buildSex()
    > 		+void buildFace()
    > 		+void buildCostume()
    > 		+void buildHairStyle()
    > 	}
    > 
    > 	class ActorController{
    > 		+Actor construct(ActorBuilder)
    > 	}
    > ```
    > ```c++
    > //‰ª•‰∏äClass DiagramÁöÑÂØ¶Èöõ‰æãÂ≠ê
    > //Actor(Product)
    > class Actor{
    >     private:
    > 		std::string type;
    >     	std::string sex; 
    >     	std::string face
    >     	std::string costume;
    >     	std::string hairStyle;
    >     public:
    >     	void setType(std::string type){
    >             //set the type
    >         }
    > 
    >     	void setSex(std::string sex){
    >             //set the sex
    >         }
    > 
    >     	void setFace(std::string face){
    >             //set the face
    >         }
    > 
    >     	void setCostume(std::strig costume){
    >             //set the custume
    >         }
    > 
    >     	void setHairStyle(std::string HairStyle){
    >             //set the hairStyle
    >         }
    > 
    >     	std::string getType(){
    >             //return the type
    >         }
    > 
    >         std::string getSex(){
    >             //return the type
    >         }
    > 
    >         std::string getFace(){
    >             //return the type
    >         }
    > 
    >         std::string getCostume(){
    >             //return the type
    >         }
    > 
    >         std::string getHairStyle(){
    >             //return the type
    >         }
    > }
    > ```
    >
    > ```c++
    > //ActorBuilderÔºöBuilder(Abstruct)
    > class ActorBuilder{
    >     protected:
    >     	Actor* actor = new Actor();
    >     pubilc:
    >     	virtual void buildType() = 0;
    >     	virtual void buildSex() = 0;
    >         virtual void buildFace() = 0;
    >         virtual void buildCostume() = 0;
    >     	virtual void buildHairStyle() = 0;
    >         Actor* createActor(){
    >             return actor;
    >         };
    > }
    > ```
    >
    > ```c++
    > //Implement Builder
    > //Hero
    > class HeroActor{
    >     pubilc:
    >     	void buildType(){
    >             this->actor->setType("Hero");
    >         };
    >     	void buildSex(){
    >             this->actor->setSex("Male");
    >         };
    >        	void buildFace(){
    >             this->actor->setFace("Handsome");
    >         };
    >         void buildCostume(){
    >             this->actor->setCostume("Armor");
    >         };
    >     	void buildHairStyle(){
    >             this->actor->setHairStyle("Elegant");
    >         };
    > }
    > 
    > //Angle
    > class AngleActor{
    >     pubilc:
    >     	void buildType(){
    >             this->actor->setType("Angle");
    >         };
    >     	void buildSex(){
    >             this->actor->setSex("Female");
    >         };
    >        	void buildFace(){
    >              this->actor->setFace("Pretty");
    >         };
    >         void buildCostume(){
    >             this->actor->setCostume("White Skirt");
    >         };
    >     	void buildHairStyle(){
    >             this->actor->setHairStyle("Long Hair");
    >         };
    > }
    > 
    > //Devil
    > class DevilActor{
    >     pubilc:
    >     	void buildType(){
    >             this->actor->setType("Devil");
    >         };
    >     	void buildSex(){
    >             this->actor->setSex("Demon");
    >         };
    >        	void buildFace(){
    >             this->actor->setFace("gly");
    >         };
    >         void buildCostume(){
    >              this->actor->setCostume("Black Clothes");
    >         };
    >     	void buildHairStyle(){
    >             this->actor->setHairStyle("Bald");
    >         };
    > }
    > ```
    >
    > ```c++
    > //ActorContoller:Director
    > class ActorController{
    > 	public:
    >     	Actor* construct(ActorBuilder ab){
    >             //ActorÁöÑÂª∫ÊßãÈÅéÁ®ã
    >             Actor* actor;
    >             ab->buildType();
    >             ab->buildSex();
    >             ab->buildFace();
    >             ab->buildCostume();
    >             ab->buildHairStyle();
    >             actor = ab->createActor();
    >             retur actor; //ËøîÂõûÂª∫ÊßãÂÆåÊàêÁöÑActor
    >         }
    > }
    > ```
    >
    > ```c++
    > //Client
    > int main(){
    >     //ÁîüÊàêhero actor
    >     ActorBuilder* heroBuilder = new HeroBuilder();
    >     ActorController* acController = new ActorController();
    >     Actor* ac = acController(heroBuilder);
    > 
    >     //ÁîüÊàêAngel actor
    >     ActorBuilder* angelBuilder = new angelBuilder();
    >     ActorController* acController2 = new ActorController();
    >     Actor* ac = acController2(angelBuilder);
    > 
    >     //ÁîüÊàêDevil actor
    >     ActorBuilder* devilBuilder = new DevilBuilder();
    >     ActorController* acController3 = new ActorController();
    >     Actor* ac = acController3(devilBuilder);
    > }
    > ```
    >
    > > **ÂèØ‰ª•Á∞°Âåñ‰ª•‰∏ä‰æãÂ≠ê(Â¶Ç‰ΩïÂª∫ÊßãÁöÑÈÅéÁ®ã‰∏çË§áÈõúÔºåÂèØ‰ª•ÊääDirectorÁöÑ``construct``ÂØ´Âà∞builder``static method``)**
    > >
    > > ```c++
    > > class ActorBuilder{
    > >  protected:
    > >  	static Actor* actor = new Actor();
    > >  pubilc:
    > >  	virtual void buildType() = 0;
    > >  	virtual void buildSex() = 0;
    > >      virtual void buildFace() = 0;
    > >      virtual void buildCostume() = 0;
    > >  	virtual void buildHairStyle() = 0;
    > >      Actor* createActor(){
    > >          return actor;
    > >      };
    > > 
    > >  	static Actor* consturct(ActorBuilder* ab){
    > >          ab->buildType();
    > >          ab->buildSex();
    > >          ab->buildFace();
    > >          ab->buildCostume();
    > >          ab->buildHairStyle();
    > >          return actor;
    > >      }
    > > 
    > >  	//ÊàñËÄÖÊòØ‰∏çÈúÄË¶ÅÂèÉÊï∏,Áõ¥Êé•Ë™øÁî®Builder method,Êõ¥Âä†Á∞°Âåñ
    > >     	static Actor* consturct(){
    > >          this->buildType();
    > >          this->buildSex();
    > >          this->buildFace();
    > >          this->buildCostume();
    > >          this->buildHairStyle();
    > >          return actor;
    > >      }
    > > }
    > > 
    > > //Â¶ÇÊûúÈÄèÈÅé‰ª•‰∏äÊñπÊ≥ïÁ∞°ÂåñDirectorÔºåÁ∞°Âåñ‰∫ÜÁ≥ªÁµ±ÁöÑÁµêÊßãÔºå‰ΩÜÂä†Èáç‰∫ÜBuilder ÁöÑËÅ∑Ë≤¨
    > > //Âè™ËÉΩÊòØÂâµÂª∫ÈÅéÁ®ãÂçÅÂàÜÁ∞°ÂñÆÁöÑproduct/Âª∫Á´ãÁ∞°ÂñÆÁöÑÁî¢ÂìÅÔºåÂê¶ÂâáÈÅéÊñºË§áÈõúÂ∞±ÈÅïÂèç‰∫Ü SPP ÂñÆ‰∏ÄËÅ∑Ë≤¨
    > > ```
    > >
    > > > ÂèØ‰ª•Âú®Builder Âä†ÂÖ•`HookMethod(Èâ§Â≠ê)`ËÆì`Director`Êõ¥Âä†Á≤æÁ¥∞ÁöÑÊéßÂà∂ÊòØÂê¶Ë™øÁî®`buildPartX`ÊñπÊ≥ïÔºå`HookMethod` ÈÄöÂ∏∏ÊòØ`bool function()`,Âú®`Absturct`Êèê‰æõÈªòË™çÂØ¶Áèæ„ÄÇ
    > >
    > > ```c++
    > > //ÂÅáË®≠Ê™¢Êü•ÊòØÂê¶Bareheaded actor
    > > class ActorBuilder{
    > >  protected:
    > >  	static Actor* actor = new Actor();
    > >  pubilc:
    > >  	virtual void buildType() = 0;
    > >  	virtual void buildSex() = 0;
    > >      virtual void buildFace() = 0;
    > >      virtual void buildCostume() = 0;
    > >  	virtual void buildHairStyle() = 0;
    > >      Actor* createActor(){
    > >          return actor;
    > >      };
    > > 	
    > >     bool isBareheaded(){return false;}
    > > }
    > > //ÂÅáË®≠ÂØ¶ÁèæÁöÑActorBuilder ÊòØ Bareheaded Â∞±Override return true
    > > ```
    > >
    > > ```c++
    > > //Director class :ActorController
    > > class ActorController{
    > > 	public:
    > >     	Actor* construct(ActorBuilder ab){
    > >             //ActorÁöÑÂª∫ÊßãÈÅéÁ®ã
    > >             Actor* actor;
    > >             ab->buildType();
    > >             ab->buildSex();
    > >             ab->buildFace();
    > >             ab->buildCostume();
    > >             //ÂÖàÊ™¢Êü•ÊòØÂê¶Bareheaded ÈÄ≤Ë°åÊéßÂà∂ÊòØÂê¶Ë¶ÅÈÄ≤Ë°åbuildHair
    > >             if(!ab->isBareheaded()){
    > >                 ab->buildHairStyle();
    > >             }
    > >             actor = ab->createActor();
    > >             retur actor; //ËøîÂõûÂª∫ÊßãÂÆåÊàêÁöÑActor
    > >         }
    > > }
    > > ```
    > >
    > > > `HookMethod`‰Ωø`Director`ÊúâÊõ¥Â•ΩÂæóÊéßÂà∂ÊòØÂê¶ÈúÄË¶ÅÂü∑Ë°å`buildPartX`ÊñπÊ≥ï

---
